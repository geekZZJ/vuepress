# 计算机网络

## 从浏览器地址栏输入 url 到请求返回发生了什么

- **解析 URL**

输入 URL 后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求

1. 浏览器发送请求前，根据请求头的 expires 和 cache-control 判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步
2. 没有命中强缓存规则，浏览器会发送请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 检查资源是否更新，若资源未更新，返回 304，告诉浏览器直接从缓存获取资源，否则进入下一步
3. 如果前两步都没有命中，则返回资源和 200 状态码

- **浏览器缓存**

1. 强缓存  
   强缓存就是向浏览器缓存中查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存又分为两种`Expires`和`Cache-Control`
   ![强缓存规则](/network/1.png "强缓存规则")  
   ![Expires与Cache-Control](/network/2.png "Expires与Cache-Control")
2. 协商缓存  
   协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程  
   ![协商缓存规则](/network/3.png "协商缓存规则")
   ![ETag](/network/4.png "ETag")

- **DNS 域名解析**

在发起 http 请求之前，浏览器首先要去获得我们想访问网页的 IP 地址，浏览器会发送一个 UDP 的包给 DNS 域名解析服务器  
![DNS域名解析过程](/network/5.png "DNS域名解析过程")

1. 递归查询
   我们的浏览器、操作系统、路由器都会缓存一些 URL 对应的 IP 地址，统称为 DNS 高速缓存。这是为了加快 DNS 解析速度，使得不必每次都到根域名服务器中去查询  
   ![递归查询](/network/6.png "递归查询")
2. 迭代查询  
   迭代查询的方式就是，局部的 DNS 服务器并不会自己向其他服务器进行查询，而是把能够解析该域名的服务器 IP 地址返回给客户端，客户端会不断地向这些服务器进行查询，直到查询到位置，迭代查询只会帮你找到相关的服务器，然后说我现在比较忙，你自己去找吧  
   ![迭代查询](/network/7.png "迭代查询")
3. DNS 负载均衡  
   DNS 还有负载均衡的作用，现在很多网站都有多个服务器，当一个网站访问量过大的时候，如果所有请求都请求在同一个服务器上，可能服务器就会崩掉，这时候就用到了 DNS 负载均衡技术，当一个网站有多个服务器地址时，在应答 DNS 查询的时候，DNS 服务器会对每个查询返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。例如可以根据每台机器的负载量，或者该机器距离用户的地理位置距离等等条件
4. DNS 预解析  
   大型网站，有多个不同服务器资源的情况下，都可采取 DNS 预解析，提前解析，减少页面卡顿
   ![DNS预解析](/network/8.png "DNS预解析")

- **TCP/IP 连接：三次握手**

![经典五层模型](/network/9.png "经典五层模型")
客服端和服务端在进行 http 请求和返回的过程中，需要创建 TCP connection（由客户端发起），http 不存在连接这个概念，它只有请求和响应。请求和响应都是数据包，它们之间的传输通道就是 TCP connection
![三次握手](/network/10.png "三次握手")
第一次握手：主机 A 发送位码为`SYN＝1`，随机产生`Seq number=1234567`的数据包到服务器，主机 B 由`SYN=1`知道，A 要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）  
第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送`ACK number=(主机A的Seq+1)`，`SYN=1`，随机产生`Seq=7654321`的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）  
第三次握手：主机 A 收到后检查`ACK number`是否正确，即第一次发送的`Seq number+1`，以及位码`SYN`是否为 1，若正确，主机 A 会再发送`ACK number=(主机B的seq+1)`，主机 B 收到后确认`Seq`值与`ACK=7654321+1`则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

> 为什么需要三次握手，两次不行吗？  
> 其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力,第二次握手，服务端 SYN=1,Seq=Y 就确认了发送能力,ACK=X+1 就确认了接收能力,所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象

> 三次握手过程中可以携带数据吗？  
> 其实第三次握手的时候，是可以携带数据的。但是第一次、第二次握手不可以携带数据  
> 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文  
> 也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病

> SYN 攻击？  
> 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击。SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 则回复确认包，并等待 Client 确认，由于源地址不存在，因此 Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击

- **发送 HTTP 请求**

拓展：HTTPS
在 HTTP 的基础上再加一层 TLS（传输层安全性协议）或者 SSL（安全套接层），就构成了 HTTPS 协议  
HTTPS 默认工作在 TCP 协议 443 端口，它的工作流程一般如以下方式：

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash 算法进行数据完整性保护，保证数据不被篡改

![TSL握手](/network/11.png "TSL握手")

1. 客户端向服务端发送 Client Hello 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；
2. 服务端收到客户端支持的协议版本、加密算法等信息后；

- 向客户端发送 Server Hello 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；
- 向客户端发送 Certificate 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；
- 向客户端发送 Server Key Exchange 消息，传递公钥以及签名等信息；
- 向客户端发送可选的消息 Certificate Request，验证客户端的证书；
- 向客户端发送 Server Hello Done 消息，通知服务端已经发送了全部的相关信息；

3. 客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；

- 向服务端发送 Client Key Exchange 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（Pre Master Secret）；
- 向服务端发送 Change Cipher Spec 消息，通知服务端后面的数据段会加密传输；
- 向服务端发送 Finished 消息，其中包含加密后的握手信息；

4. 服务端收到 Change Cipher Spec 和 Finished 消息后；

- 向客户端发送 Change Cipher Spec 消息，通知客户端后面的数据段会加密传输；
- 向客户端发送 Finished 消息，验证客户端的 Finished 消息并完成 TLS 握手；

> 服务端有公钥和私钥，公钥只能由私钥解开。客户端生成的第 2 个随机数为预主密钥，需要用服务端返回的公钥加密发送到服务端。服务端通过私钥解密得到预主密钥。客服端和服务端分别用第 1 随机数、第 2 随机数、预主密钥计算出会话密钥
> ![TSL握手](/network/12.png "TSL握手")
> HTTPS 连接，需要 7 次握手，3 次 TCP + 4 次 TLS

- **服务器处理请求并返回 HTTP 报文**

- **浏览器渲染页面**
  ![浏览器渲染过程](/network/13.png "浏览器渲染过程")

- **断开连接：TCP 四次挥手**
  ![四次挥手](/network/14.png "四次挥手")

1. 刚开始双方都处于 established 状态，假如是客户端先发起关闭请求
2. 第一次挥手：客户端发送一个`FIN`报文，报文中会指定一个序列号。此时客户端处于`FIN_WAIT1`状态
3. 第二次挥手：服务端收到`FIN`之后，会发送`ACK`报文，且把客户端的序列号值+1 作为`ACK`报文的序列号值，表明已经收到客户端的报文了，此时服务端处于`CLOSE_WAIT`状态
4. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送`FIN`报文，且指定一个序列号。此时服务端处于`LAST_ACK`的状态
5. 需要过一阵子以确保服务端收到自己的`ACK`报文之后才会进入`CLOSED`状态，服务端收到`ACK`报文之后，就处于关闭连接了，处于`CLOSED`状态
   > 挥手为什么需要四次？  
   > 因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手
   > 为什么客户端发送 ACK 之后不直接关闭，而是要等 2MSL 才关闭？  
   > 理论上，四个报文都发送完毕，就可以直接进入 CLOSE 状态了，但是可能网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端；1 个 MSL 确保对端没有收到 ACK ，重传的 FIN 报文可以到达主动关闭方

详细解析：[从输入 URL 开始建立前端知识体系](https://juejin.cn/post/6935232082482298911 "从输入 URL 开始建立前端知识体系")

## HTTP2 的多路复用

在 HTTP1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成

HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接的限制。HTTP2 中

- 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗
- 单个连接上可以并行交错的请求和响应，之间互不干扰
